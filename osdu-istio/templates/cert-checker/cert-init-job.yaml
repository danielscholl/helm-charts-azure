{{- if eq .Values.global.istio.certJob.enabled true }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.global.istio.certJob.name }}
  namespace: {{ .Release.Namespace }}
  annotations:
  {{- include "job.annotations" . | indent 4 }}
  labels:
    app: "{{ .Values.global.istio.certJob.name }}"
spec:
  backoffLimit: 2
  template:
    metadata:
      labels:
        aadpodidbinding: osdu-appgw-identity
    spec:
      serviceAccount: {{ .Values.global.istio.certJob.name }}
      containers:
      - name: cert-checker
        image: {{ .Values.global.istio.certJob.image }}
        env:
          - name: ENV_VAULT
            value: {{ .Values.global.azure.keyvault }}
          - name: K8S_NAMESPACE_NAME
            value: {{ .Release.Namespace }}
          - name: SR_RG
            value: {{ .Values.global.azure.srResourceGroupName }}
          - name: APPGW_NAME
            value: {{ .Values.global.azure.appGwName }}
          - name: K8S_CERT_SECRET
            value: {{ include "secret.certName" . }}
          - name: KV_CERT_NAME
            value: {{ include "secret.certName" . }}
        command:
        - /bin/sh
        args:
        - -c
        - |
          SIDECAR_PORT=15020
          K8S_ISTIONAMESPACE_NAME=istio-system
          # Compare expire dates and cn of certificates in Key Vault and in istio-system namespaces
          function check_cert_match() {
            # Login to common resource (Already logged in)
            # az login --identity
            echo "[INFO] Getting secret id from appgw"
            APPGW_SECRET_ID=$(az network application-gateway http-listener show -g ${SR_RG} --gateway-name ${APPGW_NAME} --name https-$(echo ${SR_RG} | sed 's/-rg/-vnet-httplstn/') --query 'sslCertificate.id' -o tsv)
            export KV_CERT_NAME=$(az network application-gateway ssl-cert show --ids ${APPGW_SECRET_ID} --query 'name' -o tsv)
            echo "[INFO] Appgw Secret configured: ${APPGW_SECRET_ID}"
            echo "[INFO] KV Secret Name: ${KV_CERT_NAME}"

            echo "[INFO] Compare expire dates of certificates in Key Vault and in istio-system namespaces"
            echo "[INFO] k8s/${K8S_CERT_SECRET} == ${ENV_VAULT}/${KV_CERT_NAME} ??"
            echo "[INFO] Keyvault secret decode: "
            az keyvault certificate download  --vault-name  ${ENV_VAULT}  -n ${KV_CERT_NAME} --file ${KV_CERT_NAME}.pem
            KV_CERT_EXPIREDATE=$(openssl x509 -in ${KV_CERT_NAME}.pem -enddate -noout |  cut -d '=' -f2)
            KV_SUBJECT_NAME=$(openssl x509 -in ${KV_CERT_NAME}.pem  -subject -noout | cut -d '=' -f3 | sed 's/ //g')
            KV_CERT_EXPIREDATE=$(date "+%Y-%m-%d" --date="${KV_CERT_EXPIREDATE}")
            KV_SUM=$(echo $KV_SUBJECT_NAME $KV_CERT_EXPIREDATE | sha1sum | awk '{print $1}')

            # Login to AKS (Not needed, using RBAC)

            echo "[INFO] K8s secret decode: "
            kubectl get secret -n ${K8S_ISTIONAMESPACE_NAME} ${K8S_CERT_SECRET} -o jsonpath='{.data.tls\.crt}' | base64 -d > cert.crt
            SECRET_CERT_EXPIRE_DATE=$(openssl x509 -in cert.crt -enddate -noout |  cut -d '=' -f2)
            K8S_SUBJECT_NAME=$(openssl x509 -in cert.crt  -subject -noout | cut -d '=' -f3 | sed 's/ //g')
            SECRET_CERT_EXPIRE_DATE=$(date "+%Y-%m-%d" --date="${SECRET_CERT_EXPIRE_DATE}")
            K8S_SUM=$(echo $K8S_SUBJECT_NAME $SECRET_CERT_EXPIRE_DATE | sha1sum | awk '{print $1}')

            if [ ${K8S_SUM} = ${KV_SUM} ]; then
              echo "$K8S_SUBJECT_NAME $SECRET_CERT_EXPIRE_DATE ==  $KV_SUBJECT_NAME $KV_CERT_EXPIREDATE"
              echo "The cert in secret is up to date"
              exit 0
            else
              echo "$K8S_SUBJECT_NAME $SECRET_CERT_EXPIRE_DATE =/=  $KV_SUBJECT_NAME $KV_CERT_EXPIREDATE"
              echo "The cert in secret is not up to date"
              echo "[INFO] Starting update routine"
            fi
            rm -f ${KV_CERT_NAME}.pem
          }

          # Cleanup function
          cleanup() {
              echo "Clean all existing files"
              rm -fv clcert.crt cacert.crt cert.pem cert.crt cert.key osdu-certificate.pfx ${KV_CERT_NAME}.pem ${KV_CERT_NAME}.pfx || echo "[WARN] Cleanup not complete correctly"
              #curl -X POST "http://localhost:${SIDECAR_PORT}/quitquitquit"
          }

          trap cleanup 0 2 3 6 ERR

          set -e
          # Wait for internet connection
          until nc -z google.com 80
          do
            sleep 1
          done
          
          # Install kubectl
          if [ ! -x /usr/local/bin/kubectl ]; then
            echo "Download and install kubectl..."
            curl -Lo /usr/local/bin/kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
            chmod a+x /usr/local/bin/kubectl
          fi

          # Get kv information
          az login --identity

          # Install coreutils
          apk add --update coreutils

          check_cert_match

{{- if include "secret.istioKeyvaultCert" . }}
          # Download BYOC certificate from keyvault
          echo "[INFO] Download BYOC certificate from keyvault"
          az keyvault secret download --file ${KV_CERT_NAME}.pfx --vault-name ${ENV_VAULT} --encoding base64 --name ${KV_CERT_NAME}
                  
          # Extract key and crt
          openssl pkcs12 -in ${KV_CERT_NAME}.pfx -out cert.pem -passin pass:"" -nodes -passout pass:""
          openssl rsa -in cert.pem -out cert.key
          echo "[INFO] Extracted the private key succesfully"

          openssl pkcs12 -in ${KV_CERT_NAME}.pfx -nokeys -clcerts -out clcert.crt -passin pass:""
          openssl pkcs12 -in ${KV_CERT_NAME}.pfx -nokeys -cacerts -out cacert.crt -passin pass:""
       
          rm -f cert.crt
          cat clcert.crt cacert.crt > cert.crt
          echo "[INFO] Extracted the certificate list succesfully"

          # Create secret for istio-ingressgateway in istio-system namespace
          kubectl create secret -n ${K8S_NAMESPACE_NAME} tls ${K8S_CERT_SECRET} \
          --save-config --dry-run=client \
          --cert=cert.crt --key=cert.key \
          -o yaml | kubectl apply -f -

          # Restart istio-ingressgateway pods (Not needed after istio 1.8)
          sleep 5
          check_cert_match
          echo "Cannot update cert in secret"
          exit 1

{{ else }}
          echo "[INFO] Getting secrets from ${K8S_NAMESPACE_NAME} and upload to kv"
          if ! kubectl get secret -n ${K8S_NAMESPACE_NAME} ${K8S_CERT_SECRET}; then
            echo "[WARN] Cert Secret not yet installed properly, leveraging to cronjob"
            exit 0
          fi
          # Get osdu-certificate secret created by cert-manager in osdu namespace and extract key and crt
          kubectl get secret -n ${K8S_NAMESPACE_NAME} ${K8S_CERT_SECRET} -o jsonpath="{ .data.tls\.crt }" | base64 -d > cert.crt
          kubectl get secret -n ${K8S_NAMESPACE_NAME} ${K8S_CERT_SECRET} -o jsonpath="{ .data.tls\.key }" | base64 -d > cert.key

          # Create secret for istio-ingressgateway in istio-system namespace from key and crt (Not needed as cert/istio)
          # Create certificate file
          openssl pkcs12 \
            -passout pass: \
            -export \
            -out osdu-certificate.pfx \
            -in cert.crt \
            -inkey cert.key

          # Upload certificate file in Key Vault to use in in AppGW
          echo "[INFO] Uploading osdu-certificate.pfx to kv..."
          SECRET_ID=$(az keyvault certificate import --vault-name ${ENV_VAULT} -n ${KV_CERT_NAME} -f osdu-certificate.pfx -o tsv --query 'sid')
          echo "[INFO] Updating secret id in ssl appgw profile $SECRET_ID"
          az network application-gateway ssl-cert create --resource-group ${SR_RG} \
            --gateway-name ${APPGW_NAME} --name ${KV_CERT_NAME} \
            --key-vault-secret-id ${SECRET_ID} || az network application-gateway ssl-cert update \
            --resource-group ${SR_RG} --gateway-name ${APPGW_NAME} \
            --name ${KV_CERT_NAME} \
            --key-vault-secret-id ${SECRET_ID}
          HTTPS_LISTENER=https-$(echo ${SR_RG} | sed 's/-rg/-vnet-httplstn/')
          echo "[INFO] Updating listener $HTTPS_LISTENER || with SSL $KV_CERT_NAME"
          az network application-gateway http-listener update --resource-group ${SR_RG} \
            --gateway-name ${APPGW_NAME} \
            --name ${HTTPS_LISTENER} \
            --ssl-cert ${KV_CERT_NAME}
          sleep 5
          check_cert_match
          echo "Cannot update cert in secret"
          exit 1
{{- end }} 
      restartPolicy: Never
{{- end }}
