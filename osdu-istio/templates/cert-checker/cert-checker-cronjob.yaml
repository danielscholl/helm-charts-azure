{{- if eq .Values.global.istio.certJob.enabled true }}
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ .Values.global.istio.certJob.name }}
  namespace: {{ .Release.Namespace }}
  labels:
    app: "{{ .Values.global.istio.certJob.name }}"
spec:
  schedule: "0 */6 * * *"  # Each 6 hours
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  jobTemplate:
    metadata:
      name: "{{ .Values.global.istio.certJob.name }}"
      labels:
        app: "{{ .Values.global.istio.certJob.name }}"
        type: "job"
    spec:
      backoffLimit: 1
      template:
        metadata:
          labels:
            aadpodidbinding: osdu-appgw-identity
        spec:
          serviceAccount: {{ .Values.global.istio.certJob.name }}
          containers:
          - name: cert-checker
            image: {{ .Values.global.istio.certJob.image }}
            env:
            - name: ENV_VAULT
              value: {{ .Values.global.azure.keyvault }}
            - name: K8S_NAMESPACE_NAME
              value: {{ .Release.Namespace }}
            - name: SR_RG
              value: {{ .Values.global.azure.srResourceGroupName }}
            - name: APPGW_NAME
              value: {{ .Values.global.azure.appGwName }}
            - name: K8S_CERT_SECRET
              value: {{ include "secret.certName" . }}
            - name: KV_CERT_NAME
              value: {{ include "secret.certName" . }}
            command:
            - /bin/sh
            args:
            - -c
            - |
              SIDECAR_PORT=15020
              K8S_ISTIONAMESPACE_NAME=istio-system

              # Compare expire dates of certificates in Key Vault and in istio-system namespaces
              function check_expire_date() {
                # Login to common resource (Already logged in)
                # az login --identity
                echo "[INFO] Getting secret id from appgw"
                APPGW_SECRET_ID=$(az network application-gateway http-listener show -g ${SR_RG} --gateway-name ${APPGW_NAME} --name https-$(echo ${SR_RG} | sed 's/-rg/-vnet-httplstn/') --query 'sslCertificate.id' -o tsv)
                export KV_CERT_NAME=$(az network application-gateway ssl-cert show --ids ${APPGW_SECRET_ID} --query 'name' -o tsv)
                echo "[INFO] Appgw Secret configured: ${APPGW_SECRET_ID}"
                echo "[INFO] KV Secret Name: ${KV_CERT_NAME}"

                echo "[INFO] Compare expire dates of certificates in Key Vault and in istio-system namespaces"
                echo "[INFO] k8s/${K8S_CERT_SECRET} == ${ENV_VAULT}/${KV_CERT_NAME} ??"
                echo "[INFO] Keyvault secret decode: "
                az keyvault certificate download  --vault-name  ${ENV_VAULT}  -n ${KV_CERT_NAME} --file ${KV_CERT_NAME}.pem
                KV_CERT_EXPIREDATE=$(openssl x509 -in ${KV_CERT_NAME}.pem -enddate -noout |  cut -d '=' -f2)
                KV_CERT_EXPIREDATE=$(date "+%Y-%m-%d" --date="${KV_CERT_EXPIREDATE}")

                # Login to AKS (Not needed, using RBAC)

                echo "[INFO] K8s secret decode: "
                kubectl get secret -n ${K8S_ISTIONAMESPACE_NAME} ${K8S_CERT_SECRET} -o jsonpath='{.data.tls\.crt}' | base64 -d > cert.crt
                SECRET_CERT_EXPIRE_DATE=$(openssl x509 -in cert.crt -enddate -noout |  cut -d '=' -f2)
                SECRET_CERT_EXPIRE_DATE=$(date "+%Y-%m-%d" --date="${SECRET_CERT_EXPIRE_DATE}")

                if [ ${KV_CERT_EXPIREDATE} = ${SECRET_CERT_EXPIRE_DATE} ]; then
                  echo "KV_CERT_EXPIREDATE: ${KV_CERT_EXPIREDATE} and SECRET_CERT_EXPIRE_DATE: ${SECRET_CERT_EXPIRE_DATE}"
                  echo "The cert in secret is up to date"
                  exit 0
                else
                  echo "KV_CERT_EXPIREDATE: ${KV_CERT_EXPIREDATE} and SECRET_CERT_EXPIRE_DATE: ${SECRET_CERT_EXPIRE_DATE}"
                  echo "The cert in secret is not up to date"
                fi
                rm -f ${KV_CERT_NAME}.pem
              }

              # Cleanup function
              cleanup() {
                echo "Clean all existing files"
                rm -fv clcert.crt cacert.crt cert.pem cert.crt cert.key osdu-certificate.pfx ${KV_CERT_NAME}.pem ${KV_CERT_NAME}.pfx || echo "[WARN] Cleanup not complete correctly"
                #curl -X POST "http://localhost:${SIDECAR_PORT}/quitquitquit"
              }

              trap cleanup 0 2 3 6 ERR

              set -e
              # Wait for internet connection
              until nc -z google.com 80
              do
                sleep 1
              done

              # Install kubectl
              if [ ! -x /usr/local/bin/kubectl ]; then
                echo "Download and install kubectl..."
                curl -Lo /usr/local/bin/kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
                chmod a+x /usr/local/bin/kubectl
              fi

              # Install coreutils
              apk add --update coreutils

              # Log In in Azure
              az login --identity
              # Check certificate expire date.
              check_expire_date

{{- if include "secret.istioKeyvaultCert" . }}
              # Download BYOC certificate from keyvault
              echo "Download BYOC certificate from keyvault"
              az keyvault secret download --file ${KV_CERT_NAME}.pfx --vault-name ${ENV_VAULT}  --encoding base64 --name ${KV_CERT_NAME}

              # Extract key and crt
              openssl pkcs12 -in ${KV_CERT_NAME}.pfx -out cert.pem -passin pass:"" -nodes -passout pass:""
              openssl rsa -in cert.pem -out cert.key
              echo "Extracted the private key succesfully"
              
              openssl pkcs12 -in ${KV_CERT_NAME}.pfx -nokeys -clcerts -out clcert.crt -passin pass:""
              openssl pkcs12 -in ${KV_CERT_NAME}.pfx -nokeys -cacerts -out cacert.crt -passin pass:""
              
              rm -f cert.crt
              cat clcert.crt cacert.crt > cert.crt
              echo "Extracted the certificate list succesfully"

              # Create secret for istio-ingressgateway in istio-system namespace
              kubectl create secret -n ${K8S_NAMESPACE_NAME} tls ${K8S_CERT_SECRET} \
              --save-config --dry-run=client \
              --cert=cert.crt --key=cert.key \
              -o yaml | kubectl apply -f -

              sleep 5
              # Check certificate expire date one more time
              check_expire_date

              echo "Cannot update cert in secret"
              exit 1

    {{ else }}
              # Get osdu-certificate secret created by cert-manager in osdu namespace and extract key and crt
              echo "[INFO] Getting secrets from ${K8S_NAMESPACE_NAME} and upload to kv"
              kubectl get secret -n ${K8S_NAMESPACE_NAME} ${K8S_CERT_SECRET} -o jsonpath="{ .data.tls\.crt }" | base64 -d > cert.crt
              kubectl get secret -n ${K8S_NAMESPACE_NAME} ${K8S_CERT_SECRET} -o jsonpath="{ .data.tls\.key }" | base64 -d > cert.key

              # Create secret for istio-ingressgateway in istio-system namespace from key and crt (Not needed as cert/istio)
              # Create certificate file
              openssl pkcs12 \
                -passout pass: \
                -export \
                -out osdu-certificate.pfx \
                -in cert.crt \
                -inkey cert.key

              # Upload certificate file in Key Vault to use in in AppGW
              echo "[INFO] Uploading osdu-certificate.pfx to kv..."
              SECRET_ID=$(az keyvault certificate import --vault-name ${ENV_VAULT} -n ${KV_CERT_NAME} -f osdu-certificate.pfx -o tsv --query 'sid')
              echo "[INFO] Updating secret id in ssl appgw profile $SECRET_ID"
              az network application-gateway ssl-cert create --resource-group ${SR_RG} \
                --gateway-name ${APPGW_NAME} --name ${KV_CERT_NAME} \
                --key-vault-secret-id ${SECRET_ID} || az network application-gateway ssl-cert update \
                --resource-group ${SR_RG} --gateway-name ${APPGW_NAME} \
                --name ${KV_CERT_NAME} \
                --key-vault-secret-id ${SECRET_ID}
              HTTPS_LISTENER=https-$(echo ${SR_RG} | sed 's/-rg/-vnet-httplstn/')
              echo "[INFO] Updating listener $HTTPS_LISTENER || with SSL $KV_CERT_NAME"
              az network application-gateway http-listener update --resource-group ${SR_RG} \
                --gateway-name ${APPGW_NAME} \
                --name ${HTTPS_LISTENER} \
                --ssl-cert ${KV_CERT_NAME}

              # Check certificate expire date one more time
              check_expire_date

              echo "Cannot update KV cert"
              exit 1
    {{- end }}  
          restartPolicy: Never         
{{- end }}